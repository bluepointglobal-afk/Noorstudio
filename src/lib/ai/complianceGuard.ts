// Compliance Guard for Image Generation
// Ensures covers and illustrations maintain strict standards
// Prevents hallucinations and maintains character consistency

import { StoredCharacter } from "@/lib/storage/charactersStore";
import { StoredProject } from "@/lib/storage/projectsStore";
import { KBRulesSummary } from "@/lib/storage/knowledgeBaseStore";

// ============================================
// Types
// ============================================

export interface ComplianceContext {
    project: StoredProject;
    characters: StoredCharacter[];
    kbSummary: KBRulesSummary | null;
}

export interface CoverComplianceRules {
    // Text elements that MUST NOT be generated by AI
    // These will be added in post-processing
    prohibitedTextElements: string[];

    // Required metadata for covers
    titleExact: string;
    authorName: string | null;
    ageRange: string;

    // Style consistency requirements
    mustMatchCharacterStyle: boolean;
    primaryStyleId: string;

    // Character requirements
    maxCharactersOnCover: number;
    characterPoseSheetReferences: string[];
}

export interface IllustrationComplianceRules {
    // Character consistency
    characterReferenceRequired: boolean;
    poseSheetMandatory: boolean;

    // Scene requirements
    maxCharactersPerScene: number;

    // Style lock
    styleId: string;
    styleMustMatch: boolean;

    // Character identity anchors (immutable visual traits)
    characterAnchors: CharacterAnchor[];
}

export interface CharacterAnchor {
    characterId: string;
    characterName: string;

    // Immutable visual traits that MUST be preserved
    skinTone: string;
    hairOrHijab: string;
    hijabRequired: boolean;
    clothingStyle: string;

    // Reference image URL
    referenceImageUrl: string | null;
    poseSheetUrl: string | null;

    // Distinguishing features
    distinguishingFeatures: string[];
}

export interface ComplianceResult {
    valid: boolean;
    warnings: string[];
    errors: string[];
    correctedPrompt?: string;
}

// ============================================
// Cover Compliance Functions
// ============================================

/**
 * Build compliance rules for cover generation.
 * These rules ensure covers maintain exact metadata and visual consistency.
 */
export function buildCoverComplianceRules(
    context: ComplianceContext
): CoverComplianceRules {
    const { project, characters } = context;

    // Get primary style from characters (use first character's style)
    const primaryStyleId = characters[0]?.visualDNA?.style || "pixar-3d";

    // Collect all pose sheet references
    const poseSheetRefs = characters
        .filter((c) => c.poseSheetUrl)
        .map((c) => c.poseSheetUrl as string);

    return {
        prohibitedTextElements: [
            "title",
            "author name",
            "age range",
            "barcode",
            "ISBN",
            "publisher logo",
            "any text",
            "any words",
            "any letters",
        ],
        titleExact: project.title,
        authorName: null, // To be set by user in export phase
        ageRange: project.ageRange,
        mustMatchCharacterStyle: true,
        primaryStyleId,
        maxCharactersOnCover: 2, // Best practice for cover clarity
        characterPoseSheetReferences: poseSheetRefs,
    };
}

/**
 * Validate and enhance a cover generation prompt.
 * Adds mandatory compliance instructions.
 */
export function enforceComplianceCoverPrompt(
    basePrompt: string,
    rules: CoverComplianceRules,
    coverType: "front" | "back"
): ComplianceResult {
    const warnings: string[] = [];
    const errors: string[] = [];

    // Check if base prompt mentions text generation (bad)
    const textMentionPatterns = [
        /add.*text/i,
        /include.*title/i,
        /write.*author/i,
        /generate.*words/i,
    ];

    for (const pattern of textMentionPatterns) {
        if (pattern.test(basePrompt)) {
            warnings.push(
                "Prompt mentions text generation which will be blocked. Text should be added in post-processing."
            );
        }
    }

    // Build compliance block
    const complianceBlock = buildCoverComplianceBlock(rules, coverType);

    // Insert compliance instructions at start and end for maximum adherence
    const correctedPrompt = `${complianceBlock.header}\n\n${basePrompt}\n\n${complianceBlock.footer}`;

    return {
        valid: errors.length === 0,
        warnings,
        errors,
        correctedPrompt,
    };
}

function buildCoverComplianceBlock(
    rules: CoverComplianceRules,
    coverType: "front" | "back"
): { header: string; footer: string } {
    const header = `## CRITICAL COMPLIANCE REQUIREMENTS - READ FIRST
!!! ABSOLUTE REQUIREMENTS - FAILURE TO COMPLY WILL RESULT IN REJECTION !!!

1. **NO TEXT GENERATION**: Do NOT generate ANY text, letters, words, or symbols.
   - No title text
   - No author name
   - No age indicators  
   - No watermarks or logos
   - LEAVE BLANK SPACE where text would normally appear
   - Text will be added separately in post-processing

2. **CHARACTER CONSISTENCY**: Characters MUST match their reference images EXACTLY.
   - Same face structure
   - Same skin tone
   - Same hair/hijab style and color
   - Same clothing style and colors
   - If reference provided, use it as STRICT template

3. **ART STYLE LOCK**: Use ONLY ${rules.primaryStyleId} style.
   - Do not deviate from this style
   - Match the exact rendering style of character references

4. **COVER TYPE**: ${coverType === "front" ? "FRONT COVER" : "BACK COVER"}`;

    const footer = `## FINAL COMPLIANCE CHECKLIST (AI MUST VERIFY):
□ NO text, words, or letters anywhere in the image
□ Characters match reference images exactly
□ Art style is ${rules.primaryStyleId} throughout
□ Blank space left at ${coverType === "front" ? "TOP for title" : "CENTER for synopsis"}
□ Professional children's book quality
□ 2:3 portrait orientation
□ Cultural/modesty guidelines followed`;

    return { header, footer };
}

// ============================================
// Illustration Compliance Functions
// ============================================

/**
 * Build compliance rules for illustration generation.
 * Ensures character consistency across all scenes.
 */
export function buildIllustrationComplianceRules(
    context: ComplianceContext
): IllustrationComplianceRules {
    const { characters } = context;

    // Get primary style
    const styleId = characters[0]?.visualDNA?.style || "pixar-3d";

    // Build character anchors - immutable traits that MUST be preserved
    const characterAnchors: CharacterAnchor[] = characters.map((char) => ({
        characterId: char.id,
        characterName: char.name,
        skinTone: char.visualDNA?.skinTone || "warm olive",
        hairOrHijab: char.visualDNA?.hairOrHijab || "dark hair",
        hijabRequired: char.modestyRules?.hijabAlways || false,
        clothingStyle: char.visualDNA?.outfitRules || "modest children's clothing",
        referenceImageUrl: char.imageUrl || null,
        poseSheetUrl: char.poseSheetUrl || null,
        distinguishingFeatures: extractDistinguishingFeatures(char),
    }));

    return {
        characterReferenceRequired: true,
        poseSheetMandatory: characters.some((c) => c.poseSheetUrl),
        maxCharactersPerScene: 4, // Practical limit for clear composition
        styleId,
        styleMustMatch: true,
        characterAnchors,
    };
}

/**
 * Extract distinguishing features that make each character unique.
 */
function extractDistinguishingFeatures(char: StoredCharacter): string[] {
    const features: string[] = [];

    // From visual DNA
    if (char.visualDNA?.accessories) {
        features.push(char.visualDNA.accessories);
    }
    if (char.colorPalette && char.colorPalette.length > 0) {
        features.push(`Primary color: ${char.colorPalette[0]}`);
    }

    // Role-based features
    if (char.role) {
        features.push(`Role: ${char.role}`);
    }

    // Age-based features
    if (char.ageRange) {
        features.push(`Age appearance: ${char.ageRange} years old`);
    }

    return features;
}

/**
 * Build a character identity block for prompts.
 * This block contains immutable traits that MUST be preserved.
 */
export function buildCharacterIdentityBlock(
    anchors: CharacterAnchor[],
    sceneCharacterIds: string[]
): string {
    const relevantAnchors = anchors.filter((a) =>
        sceneCharacterIds.includes(a.characterId)
    );

    if (relevantAnchors.length === 0) {
        return "";
    }

    const sections: string[] = [
        "## CHARACTER IDENTITY LOCK - IMMUTABLE TRAITS",
        "The following character traits are LOCKED and MUST NOT be changed:",
        "",
    ];

    for (let i = 0; i < relevantAnchors.length; i++) {
        const anchor = relevantAnchors[i];
        const charSection = [
            `### CHARACTER ${i + 1}: ${anchor.characterName.toUpperCase()}`,
            `- Skin tone: ${anchor.skinTone} (EXACT MATCH REQUIRED)`,
            `- Hair/Hijab: ${anchor.hairOrHijab} (EXACT MATCH REQUIRED)`,
            anchor.hijabRequired
                ? "- HIJAB: MANDATORY in EVERY frame - must cover hair completely"
                : "",
            `- Clothing style: ${anchor.clothingStyle}`,
            anchor.distinguishingFeatures.length > 0
                ? `- Unique features: ${anchor.distinguishingFeatures.join(", ")}`
                : "",
            anchor.poseSheetUrl
                ? `- REFERENCE: Use pose sheet for exact appearance`
                : anchor.referenceImageUrl
                    ? `- REFERENCE: Use character image for reference`
                    : "",
            "",
        ];

        sections.push(...charSection.filter(Boolean));
    }

    // Add multi-character guidance if applicable
    if (relevantAnchors.length > 1) {
        sections.push("## MULTI-CHARACTER SCENE REQUIREMENTS");
        sections.push("When multiple characters appear together:");
        sections.push("- Each character MUST maintain their unique appearance");
        sections.push("- Do NOT blend or merge character features");
        sections.push("- Maintain correct relative sizes based on age");
        sections.push("- Each character should be clearly distinguishable");
        sections.push("");
    }

    return sections.join("\n");
}

/**
 * Validate and enhance an illustration prompt.
 */
export function enforceComplianceIllustrationPrompt(
    basePrompt: string,
    rules: IllustrationComplianceRules,
    sceneCharacterIds: string[]
): ComplianceResult {
    const warnings: string[] = [];
    const errors: string[] = [];

    // Check if too many characters
    if (sceneCharacterIds.length > rules.maxCharactersPerScene) {
        warnings.push(
            `Scene has ${sceneCharacterIds.length} characters. Consider limiting to ${rules.maxCharactersPerScene} for clarity.`
        );
    }

    // Check if references are available
    const referenced = sceneCharacterIds.filter((id) =>
        rules.characterAnchors.some(
            (a) => a.characterId === id && (a.poseSheetUrl || a.referenceImageUrl)
        )
    );

    if (referenced.length < sceneCharacterIds.length) {
        warnings.push(
            "Some characters lack reference images. Character consistency may vary."
        );
    }

    // Build identity block
    const identityBlock = buildCharacterIdentityBlock(
        rules.characterAnchors,
        sceneCharacterIds
    );

    // Build compliance footer
    const complianceFooter = `
## ILLUSTRATION QUALITY REQUIREMENTS
- Art style: ${rules.styleId} (MUST MATCH exactly)
- NO text, words, or letters in the image
- Characters MUST match their reference images
- Professional children's book illustration quality
- Warm, inviting lighting with soft shadows
- Cultural and modesty guidelines strictly followed
- No watermarks or signatures`;

    const correctedPrompt = `${identityBlock}\n\n${basePrompt}\n\n${complianceFooter}`;

    return {
        valid: errors.length === 0,
        warnings,
        errors,
        correctedPrompt,
    };
}

// ============================================
// Negative Prompt Builder
// ============================================

/**
 * Build a comprehensive negative prompt for covers.
 */
export function buildCoverNegativePrompt(): string {
    return [
        // Text prevention (highest priority)
        "text", "words", "letters", "numbers", "title", "author", "signature",
        "watermark", "logo", "barcode", "ISBN", "typography", "font",

        // Quality issues
        "blurry", "distorted", "low quality", "pixelated", "artifacts",
        "bad anatomy", "deformed", "ugly", "mutated", "disfigured",

        // Content issues
        "scary", "violent", "inappropriate", "revealing clothing",
        "tight clothing", "western symbols", "non-Islamic imagery",

        // Style issues  
        "photorealistic", "photograph", "3D render inconsistent",
        "mixed styles", "inconsistent lighting",

        // Orientation
        "horizontal", "landscape orientation",
    ].join(", ");
}

/**
 * Build a comprehensive negative prompt for illustrations.
 */
export function buildIllustrationNegativePrompt(): string {
    return [
        // Text prevention
        "text", "words", "letters", "numbers", "watermark", "signature",

        // Character consistency
        "different face", "changed appearance", "wrong skin tone",
        "missing hijab", "different hair color", "wrong clothing",

        // Quality issues
        "blurry", "distorted", "low quality", "artifacts",
        "bad anatomy", "deformed", "ugly",

        // Content issues
        "scary", "violent", "inappropriate", "revealing clothing",

        // Style consistency
        "photo", "realistic", "different art style",
    ].join(", ");
}

// ============================================
// Validation Helpers
// ============================================

/**
 * Validate that all characters in a scene are properly referenced.
 */
export function validateSceneCharacters(
    characters: StoredCharacter[],
    sceneDescription: string
): { valid: boolean; issues: string[] } {
    const issues: string[] = [];

    for (const char of characters) {
        // Check for locked status (best)
        if (char.status !== "locked" && char.status !== "approved") {
            issues.push(
                `Character "${char.name}" is not locked. Visual consistency may vary.`
            );
        }

        // Check for pose sheet
        if (!char.poseSheetUrl && !char.imageUrl) {
            issues.push(
                `Character "${char.name}" has no reference image. This may cause inconsistency.`
            );
        }

        // Check for modesty rules
        if (char.modestyRules?.hijabAlways && !char.visualDNA?.hairOrHijab?.toLowerCase().includes("hijab")) {
            issues.push(
                `Character "${char.name}" requires hijab but visual DNA doesn't explicitly mention it.`
            );
        }
    }

    return {
        valid: issues.length === 0,
        issues,
    };
}

/**
 * Pre-flight check for cover generation.
 */
export function preflightCoverGeneration(
    context: ComplianceContext,
    coverType: "front" | "back"
): { ready: boolean; blockers: string[]; warnings: string[] } {
    const blockers: string[] = [];
    const warnings: string[] = [];

    // Check project has title
    if (!context.project.title || context.project.title.trim().length === 0) {
        blockers.push("Project must have a title before generating cover");
    }

    // Check at least one character
    if (context.characters.length === 0) {
        blockers.push("At least one character is required for cover generation");
    }

    // Check character status
    const unlockedChars = context.characters.filter(
        (c) => c.status !== "locked" && c.status !== "approved"
    );
    if (unlockedChars.length > 0) {
        warnings.push(
            `${unlockedChars.length} character(s) are not locked. Consider locking for best consistency.`
        );
    }

    // Check for references
    const withoutRefs = context.characters.filter(
        (c) => !c.poseSheetUrl && !c.imageUrl
    );
    if (withoutRefs.length > 0) {
        warnings.push(
            `${withoutRefs.length} character(s) lack reference images.`
        );
    }

    return {
        ready: blockers.length === 0,
        blockers,
        warnings,
    };
}
